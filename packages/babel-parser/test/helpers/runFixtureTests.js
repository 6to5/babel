import { multiple as getFixtures } from "@babel/helper-fixtures";
import { codeFrameColumns } from "@babel/code-frame";
import fs from "fs";
import path from "path";
// import { fileURLToPath } from "url";
import Difference from "./difference.js";
import FixtureError2 from "./fixture-error.js";
import toFuzzedOptions from "./to-fuzzed-options.js";

const { parse: JSONParse, stringify } = JSON;

// We've only serialized one BigInt in the entire test suite:
//
// packages/babel-parser/test/fixtures/estree/basic/bigint/output.json
//
// This is because only estree actually includes the BigInt value in the Literal
// node. If the JS environemnt doesn['t support bigint, then estree will just
// use null for the value. We also happen to just throw the AST information away
// with estree tests, so in the event that we're running on an older version of
// Node that doesn't support bigint, it is safe to deserialize to null.
const toBigInt = global.BigInt || (() => null);

/* eslint-disable no-confusing-arrow */
const deserialize = string =>
  JSONParse(string, (key, value) =>
    key !== "value" || !value || typeof value !== "object" || !value[serialized]
      ? value
      : value[serialized] === "RegExp"
      ? new RegExp(value.source, value.flags)
      : toBigInt(value.value),
  );
/*
const rootPath = path.join(
  path.dirname(fileURLToPath(import.meta.url)),
  "../../../..",
);
*/
const serialized = "$$ babel internal serialized type";

class FixtureError extends Error {
  constructor(previousError, fixturePath, code) {
    super(previousError.message);
    const messageLines = (previousError.message.match(/\n/g) || []).length + 1;

    let fixtureStackFrame = "";
    if (previousError.loc) {
      fixtureStackFrame =
        codeFrameColumns(
          code,
          {
            start: {
              line: previousError.loc.line,
              column: previousError.loc.column + 1,
            },
          },
          { highlightCode: true },
        ) +
        "\n" +
        `at fixture (${fixturePath}:${previousError.loc.line}:${
          previousError.loc.column + 1
        })\n`;
    }

    this.stack =
      previousError.constructor.name +
      ": " +
      previousError.message +
      "\n" +
      fixtureStackFrame +
      previousError.stack.split("\n").slice(messageLines).join("\n");
  }
}

export default function runFixtureTests(
  fixturesPath,
  parseFunction,
  onlyCompareErrors = false,
) {
  const fixtures = getFixtures(fixturesPath);

  for (const [name, testSuites] of Object.entries(fixtures)) {
    for (const { title, tests } of testSuites) {
      for (const test of tests) {
        runAutogeneratedParseTests(
          parseFunction,
          `${name}/${title}`,
          test,
          onlyCompareErrors,
        );
      }
    }
  }
}

function runAutogeneratedParseTests(
  parse,
  prefix,
  task,
  onlyCompareErrors = false,
) {
  const { expect, options } = task;
  const testFn = task.disabled ? it.skip : it;
  const threw = options.throws ? options.throws : false;
  const ast = expect.code ? deserialize(expect.code) : false;
  const title = `${prefix}/${task.title}`;
  const toStartPosition = ({ startLine = 1, startColumn = 0 }) =>
    `(${startLine}, ${startColumn})`;

  toFuzzedOptions(options)
    .map(([adjust, options]) => ({
      ...task,
      title: `${title} start = ${toStartPosition(options)}`,
      adjust,
      options,
      source: task.actual.code,
      expected: { threw, ast },
    }))
    .forEach(test =>
      testFn(test.title, function () {
        try {
          runParseTest(parse, test, onlyCompareErrors);
        } catch (err) {
          if (!test.expect.code && !process.env.CI) {
            const fn = path.dirname(task.expect.loc) + "/options.json";
            if (!fs.existsSync(fn)) {
              test.options = task.options || {};
              test.options.throws = err.originalMessage || err.message;
              fs.writeFileSync(fn, stringify(task.options, null, 2));
            }
          }
          /*
        const fixturePath = `${path.relative(
          rootPath,
          fixturesPath,
        )}/${name}/${task.actual.filename}`;
      */
          throw new FixtureError(err, "fixturePath", task.actual.code);
        }
      }),
    );
}

const toJustErrors = result => ({
  threw: result.threw,
  ast: result.ast && { errors: result.ast.errors },
});

function runParseTest(parse, test, onlyCompareErrors) {
  const { adjust, expected, source, options } = test;

  if (expected.threw && expected.ast) {
    throw Error(
      "File expected.json exists although options specify throws. Remove expected.json.",
    );
  }

  const actual = parseWithRecovery(parse, source, options);
  const difference = new Difference(
    adjust,
    onlyCompareErrors ? toJustErrors(expected) : expected,
    onlyCompareErrors ? toJustErrors(actual) : actual,
  );

  if (difference !== Difference.None) {
    throw FixtureError2.fromDifference(difference);
  }
}

function parseWithRecovery(parse, source, options) {
  try {
    const ast = parse(source, { errorRecovery: true, ...options });

    // Normalize the AST
    //
    // TODO: We should consider doing something more involved here as
    // we may miss bugs where we put unexpected falsey objects in these
    // properties.
    if (ast.comments && !ast.comments.length) delete ast.comments;
    if (ast.errors && !ast.errors.length) delete ast.errors;
    else ast.errors = ast.errors.map(error => error + "");

    return { threw: false, ast };
  } catch (error) {
    return { threw: error.message, ast: false };
  }
}
