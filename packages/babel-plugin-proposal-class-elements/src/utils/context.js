import { types as t, traverse } from "@babel/core";
import ReplaceSupers, {
  environmentVisitor,
} from "@babel/helper-replace-supers";

export function ensureClassRef(path) {
  const originalClassRef = path.node.id;
  let classRef = originalClassRef;
  if (!classRef) {
    path.set("id", (classRef = path.scope.generateUidIdentifier("class")));
  }

  return { classRef, originalClassRef };
}

export function ensureExternalClassRef(path, classRef, originalClassRef) {
  if (path.isClassDeclaration()) {
    return classRef;
  } else {
    return originalClassRef === classRef
      ? path.scope.generateUidIdentifier(classRef.name)
      : // If the classRef has been generated by us, it's already an UUID and we
        // don't need a new id.
        classRef;
  }
}

export function replaceThisContextInExtractedNodes(
  nodes,
  extractedPaths,
  path,
  externalClassRef,
  originalClassRef,
  state,
  constantSuper,
) {
  let needsClassRef = false;

  for (let i = 0, j = 0; i < nodes.length; i++) {
    while (nodes[i] !== extractedPaths[j].node) {
      j++;
      if (j > extractedPaths.length) {
        throw new Error("Internal Babel error");
      }
    }

    needsClassRef =
      replaceThisContext(
        path,
        extractedPaths[j],
        externalClassRef,
        state,
        constantSuper,
        originalClassRef,
      ) || needsClassRef;
  }

  return needsClassRef;
}

export function replaceThisContext(
  classPath,
  fieldPath,
  ref,
  file,
  constantSuper,
  innerBindingRef,
) {
  replaceSupers(classPath, fieldPath, file, constantSuper);

  const state = { classRef: ref, needsClassRef: false };
  fieldPath.traverse(thisContextVisitor, state);

  return (
    replaceInnerBindingReferences(fieldPath, ref, innerBindingRef) ||
    state.needsClassRef
  );
}

export function replaceInnerBindingReferences(
  elemPath,
  outerBindingRef,
  innerBindingRef,
) {
  const state = { needsClassRef: false, outerBindingRef, innerBindingRef };
  if (outerBindingRef.name !== innerBindingRef?.name) {
    elemPath.traverse(innerReferencesVisitor, state);
  }
  return state.needsClassRef;
}

export function replaceSupers(classPath, elementPath, file, constantSuper) {
  if (!classPath.node.superClass) return;

  new ReplaceSupers({
    methodPath: elementPath,
    constantSuper,
    superRef: classPath.node.superClass,
    file,
    getObjectRef() {
      let { id } = classPath.node;
      if (!id) {
        id = classPath.scope.generateUidIdentifier();
        classPath.set("id", id);
      }
      id = t.cloneNode(id);

      return elementPath.node.static
        ? id
        : t.memberExpression(id, t.identifier("prototype"));
    },
  }).replace();
}

const thisContextVisitor = traverse.visitors.merge([
  {
    ThisExpression(path, state) {
      state.needsClassRef = true;
      path.replaceWith(t.cloneNode(state.classRef));
    },
  },
  environmentVisitor,
]);

const innerReferencesVisitor = {
  ReferencedIdentifier(path, state) {
    if (
      path.scope.bindingIdentifierEquals(path.node.name, state.innerBindingRef)
    ) {
      state.needsClassRef = true;
      path.node.name = state.outerBindingRef.name;
    }
  },
};

export const findBareSupers = traverse.visitors.merge([
  {
    Super(path) {
      const { node, parentPath } = path;
      if (parentPath.isCallExpression({ callee: node })) {
        this.push(parentPath);
      }
    },
  },
  environmentVisitor,
]);
